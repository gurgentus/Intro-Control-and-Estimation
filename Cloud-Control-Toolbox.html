<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Cloud Controls & Simulation Toolbox </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content="">
    <meta name="author" content="">
    <meta charset="utf-8">


    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->

    <!-- GUI -->

    <!-- jquery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script>window.jQuery || document.write('<script src="{{url_for('static', filename='jquery.js') }}">\x3C/script>')</script>
    <script type="text/javascript">
      var $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
    </script>
    <!-- jquery.terminal -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.terminal/1.6.0/js/jquery.terminal.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/jquery.terminal/1.6.0/css/jquery.terminal.min.css" rel="stylesheet"/>
    <!-- Latest compiled and minified CSS -->

    <script src="static/js/index.js"></script>
    <script>keyboardeventKeyPolyfill.polyfill();</script>

    <!-- bootstrap -->
    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">

    <link rel="shortcut icon" href="{{ url_for('static', filename='ico/favicon.ico') }}">

    <!-- bokeh -->
    <link rel="stylesheet"
     href="https://cdn.pydata.org/bokeh/release/bokeh-0.12.6.min.css"
     type="text/css" />
    <script type="text/javascript"
     src="https://cdn.pydata.org/bokeh/release/bokeh-0.12.6.min.js">
    </script>
    <script type="text/javascript">
    Bokeh.set_log_level("info");
    </script>

    <!-- latex -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script><br />
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
         equationNumbers: {  autoNumber: "AMS"  },
         extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
      }
    });
    </script>
    <script type="text/javascript"
     src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <style>
    /*.affix {
    top: 20px;
    }*/

    .affix {
      top: 20px;
      width: 40%;
    }

    .affix-top {
      /*width: 100%;*/
    }

    .affix-bottom {
      /*width: 100%;
      position: absolute;*/
    }

    #col1{
      /*background:green;*/
      max-width:600px !important;
    }

    #col2{
      /*background:yellow;*/
      max-width:600px !important;
    }

    .btn-file {
       position: relative;
       overflow: hidden;
     }

     .btn-file input[type=file] {
       position: absolute;
       top: 0;
       right: 0;
       min-width: 100%;
       min-height: 100%;
       font-size: 100px;
       text-align: right;
       filter: alpha(opacity=0);
       opacity: 0;
       outline: none;
       background: white;
       cursor: inherit;
       display: block;
     }
    </style>
  </head>
  <body data-spy="scroll" data-target="#myScrollspy" data-offset="15">

    <div class="container-fluid" style="background-color:#2196F3;color:#fff;height:220px;">
      <h1>Cloud Controls & Simulation Toolbox</h1>
      <!-- <h3>Fixed vertical sidenav on scroll</h3> -->
      <p>The main controls and simulation functionality is natively implemented in python using python flask
        framework for server side code. I implemented the mathematical computations using
        standard python libraries like numpy and scipy. The terminal functionality is
        done using JQuery Terminal.  Plotting uses the bokeh library.
        For speed the orbital mechanics toolbox executes C++ code under the hood.
         In addition, I added ability
      to execute octave commands and automatically manage the context, which right now works only if installed locally. </p>
      <p> This project is under development, so many bugs may exist.  In particular, currently sessions are not managed
      correctly so entered matrices and plots may not be saved. </p>
      <p> For questions and bugs please email me at: greg.hayrapetyan AT gmail.com.
    </div>
    <br>

    <div class="container page">
        <div class="content">

          <div class="container-fluid">
            <div class="row">
              <div id="col1" class="col-lg-6">
                <ul class="nav nav-tabs">
                  <li class="active"><a href="#general_tab" data-toggle="tab">General</a></li>
                  <li><a href="#controls_tab" data-toggle="tab">Controls Toolbox</a></li>
                  <li><a href="#orbital_tab" data-toggle="tab">Orbital Mechanics</a></li>
                  <!-- <li><a href="#nums_tab" data-toggle="tab">Numerical Solvers</a></li> -->
                  <li><a href="#scene_segment_tab" data-toggle="tab">Scene Segmentation</a></li>
                </ul>
                <div class="tab-content clearfix">

                  <div class="tab-pane active" id="general_tab">
                  <h1>Native Support</h1>
                  <p> Commands <code>display</code> and <code>gdisplay</code> are used to display stored
                    data to the console and graphical output displays respectively.
                  <h1>Octave - warning: temporarily available only with local install </h1>
                  <p>
                  Type <code>octave</code> to switch to Octave command prompt for entering octave commands (Matlab syntax).
                  </p>
                  <p>
                  At this point usual <mark>Octave</mark> commands will work.  For example,
                  <code>
                    A = [1,2;3,4]
                  </code>
                  defines a matrix.
                  </p>
                  <p>
                  Leaving Octave using <code>exit</code> command returns to the CCST prompt.
                </p>
                <p>
                  To display the matrix we can type <code>display A</code> or <code>gdisplay A</code> with the latter
                  producing latex typeset rendering of the matrix in the graphical ouput pane.
                </p>
                <p> Matrices can also be entered using the CCST with python type syntax: <code> matrix [[1,2],[3,4]]</code>.
                </div>
                <div class="tab-pane" id="controls_tab">
                <h1> Controls System Commands </h1>
                <p>
                  Let us analyze longitudinal dynamics representative of a transport aircraft, trimmed at $V_0 = 250$ ft/s and
                  flying at a low altitude.  The example is taken from 'Robust and Adaptive Control: With Aerospace Applications' by
                  Eugene Lavretsky and Kevin Wise.
                </p>
                <p>
                  The linearized dynamics are given by the matrix
                  $$
                  A =
                  \begin{pmatrix}
                  -0.038 & 18.984 & 0 & -32.174 \\
                  -0.001 & -0.632 & 1 & 0 \\
                  0 & -0.759 & -0.518 & 0 \\
                  0 & 0 & 1 & 0
                  \end{pmatrix}
                  $$
                  To enter this matrix in CCST type <code> matrix A '[[-0.038, 18.984, 0, -32.174], [-0.001,-0.632, 1, 0],
                  [0, -0.759, -0.518, 0], [0, 0, 1, 0]]'</code>
                </p>
                <p> We can enter <code> gdisplay A </code> to view the entered matrix in latex rendering under the terminal. In turn,
                  <code> display A </code> will display A in the console.
                </p>
                <p> To calculate eigenvectors and eigenvalues of A enter the command <code> modes A V E </code>, where
                  the last two arguments specify the variables were the results will be stored.
                </p>
                <p> Next, let us define a matrix $B$ with control derivatives as follows:
                  <code> matrix B '[[10.1, 0], [0, -0.0086], [0.025, -0.011], [0,0]]' </code>
                </p>
                <p>
                Finally we will define two more matrices, $C$ and $D$ to complete our state space system with state feedback.
                </p>
                <p>
                <code> matrix C '[[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]'</code>
                </p>
                <p>
                <code> matrix D '[[0, 0], [0, 0], [0, 0], [0, 0]]'</code>
                </p>
                <p>
                Next, we define the state system with the command <code>ss A B C D G</code>.  The last argument
                gives the name of the state system.  We can now graphically display the system with <code> gdisplay G </code>
                </p>
                Before connecting a feedback controller, let us simulate the angle of attack response to a step elevator command.
                We first let the system know that the elevator is the second input and the angle of attack is the second output with commands:
                </p>
                <p>
                  <code> control 2 G elevator</code>
                </p>
                <p>
                  <code> output 2 G alpha</code>
                </p>
                <p>
                Now we can simulate the response to a 0.5 radian elevator deflection for 5 seconds with:
                <code> step alpha G elevator 0.5 5 alpha_plot</code> and view the result with <code>gdisplay alpha_plot</code>.
              </p>
              <p>
              For a closed-loop system we define a controller in a standard space-state form with the command:
              </p>
              <p>
              <code>controller A B1 B2 C D1 D2 K</code>
              </p>
              <p>
              and arrange $G$ and $K$ into a feedback loop with:
              </p>
              <p>
              <code>feedback G K G_cl</code>
              </p>
              <p>
              Here, again the last argument gives a name to the resulting closed loop system.
              </p>
              <p>
              To obtain response to initial conditions we can use the command:
              </p>
              <p>
              <code>response alpha G '[[0],[0]]' '[[0]]', 5.0 closed_loop_plot</code>
              </p>
              <p>
              Here the second argument specifies the initial conditions and the third argument specifies
              the reference input.
              </p>

                </div>


                <div class="tab-pane" id="orbital_tab">
                  <h1> Orbital Mechanics Toolbox </h1>
                  <p>
                  The toolbox uses C++ code under the hood.
                </p>
                  <h1>Lambert's Problem</h1>
                  <p>
                  Consider a satellite to be located at $r_1 = 5000 \hat{I} + 10000 \hat{J} + 2100 \hat{K}$ km.
                  We want to design a trajectory that will put the satellite at $r_2 = -14600 \hat{I} + 2500 \hat{J} + 7000 \hat{K}$ km
                  after one hour.  This is achieved by solving Lambert's problem, by calling
                  </p>
                  <p>
                  <code> lambert '[5000, 10000, 2100]' '[-14600, 2500, 7000]' 3600 True 398600 orbit1</code>
                  </p>
                  <p>
                  Here we specified the two positions, time, whether we want the prograde trajectory, $\mu$, and a name to save the results under.
                  To see the orbital elements associated with the calculated orbit we simply type:
                  </p>
                  <p>
                    <code> gdisplay orbit1 </code>
                  </p>
                  <h1> Optimal Circular Orbit Transfer </h1>
                  <p>
                    Consider establishing the optimal transfer trajectory to get
                  from a given circular orbit around the earth
                  to the largest radial position in a given amount of time using constant thrust
                  and the thrust angle as the control.
                  This problem can be posed as a classic optimal control
                  problem of finding extrema of a functional of the form
                  $$
                  J(\alpha) := \int_{t_0}^{t_f} L(t,x(t),\alpha(t)) \, dt + K(t_f, x_f),
                  $$
                  where the running cost $L \equiv 0$ and the terminal cost
                  $K := r(t_f)$ is the final radial position.  Precisely,
                </p>
                  $$
                  J = r(t_f),
                  $$
                  subject to the classic two-body equations of motion in polar coordinates
                  $$
                  \begin{align}
                  \dot{r} & = u, \\
                  \dot{u} & = \frac{v^2}{r} - \frac{\mu}{r^2} + \frac{T \sin \alpha}{m_0 - |\dot{m}|t}, \\
                  \dot{v} & = -\frac{u v}{r} + \frac{T \cos\alpha}{m_0 - |\dot{m} t|}, \\
                  \dot{\theta} & = \frac{v}{r},
                  \end{align}
                  $$
                  <p>
                  where $r$ is the radial position of the vehicle, $u$ and $v$ are radial
                  and tangential velocities, $T$ is the thrust applied at the angle of $\alpha$ radians.
                  In addition, $m_0$ is the initial vehicle mass and $\dot{m}$ is the mass flow rate.
                  (See James M Longuski, José J. Guzmán, John E. Prussing, Optimal Control with Aerospace Applications-Springer-Verlag New York (2014))
                  </p>
                  <p>
                  By the use of Pontryagin's Maximum Principle, this problem can be reduced to solving
                  a boundary value problem
                  $$
                  \begin{align}
                  \frac{d \bar{r}}{d \tau} & = \bar{u} \eta, \\
                  \frac{d \bar{u}}{d \tau} & = \left( \frac{\bar{v}^2}{\bar{r} -
                  \frac{1}{\bar{r}^2}} \right) \eta + \frac{\bar{T}}{m_0 - |\dot{m}| \tau t_f}
                  \left( \frac{p_u}{\sqrt{p_u^2+p_{v}^2}} \right), \\
                  \frac{d \bar{v}}{d \tau} & = \frac{\bar{u}{\bar{v}}{\bar{r}}}\eta
                   + \frac{\bar{T}}{m_0 - |\dot{m}| \tau t_f}
                  \left( \frac{p_{v}}{\sqrt{p_u^2+p_{v}^2}} \right), \\
                  \frac{d \theta}{d \tau} & = \frac{\bar{v}{\bar{r}}} \eta, \\
                  \frac{d p_r}{d \tau} & = p_u \left(\frac{\bar{v}^2}{\bar{r}^2}
                  -\frac{2}{\bar{r}^3} \right) \eta - p_{v} \frac{\bar{u}{\bar{v}}}{\bar{r}^2} \eta
                  + \frac{p_{\theta} \bar{v}}{\bar{r}^2} \eta, \\
                  \frac{d p_u}{d \tau} & = -p_r \eta + \frac{p_{v} \bar{v}}{\bar{r}}, \\
                  \frac{d p_v}{d \tau} & = -\frac{2 p_u v \eta}{\bar{r}} +
                  \frac{p_{v} u \eta}{\bar{r}} - {p_{\theta} \eta}{\bar{r}},
                  \end{align}
                  $$
                  for the rescaled variables
                  $$
                  \bar{r} = \frac{r}{r(0)}, \, \bar{u} = \frac{u}{v(0)}, \, \bar{v} = \frac{v}{v(0)},
                  \, \tau = \frac{t}{t_f},
                  $$
                  the co-states $p_r, p_{\theta}, p_u, p_v$ and subject to the boundary conditions
                  $$
                  \begin{cases}
                  \bar{r}_0(0) = 1, \, \bar{u}(0) = 0, \, \bar{v}(0)=1, \, \theta(0) = 0, \\
                  \bar{u}(1) = 0, \, \bar{v}(1) = \sqrt{1/\bar{r}(1)}, \, 1 - p_r(1)
                   + \frac{1}{2} p_v(1) \sqrt{1/\bar{r}^3(1)} = 0, \, p_{\theta}(1) = 0
                  \end{cases}
                  $$
                  To solve the problem with $\mu = 3.986004418e5$,
                  initial mass $m_0 = 1500$ kg, specific impulse $I_{sp} = 6000$, thrust $T = 20$ N,
                  initial orbit radius $6678$ km, final time $t_f = 0.5$ days, and using 5 hour timesteps and 500
                  grid points for each timestep we run
                  </p>
                  <p>
                    <code>orb_transfer_lobatto3 3.986004418e5 1500 6000 20 6678 0.5 5 500 traj_plot </code>
                  </p>
                  <p>
                  The above solves the problem using a three stage Lobatto collocation scheme.
                  Similarly, we can run a more general collocation code by specifying the scheme at the end of the command.
                  For example, to use a trapezoid scheme,
                  $$
                  \begin{array}{c|cc}
                  0 & 0 & 0 \\
                  1 & 1/2 & 1/2 \\
                  \hline
                    & 1/2 & 1/2
                    \end{array}
                  $$
                  we can enter
                  </p>
                  <p>
                    <code>orb_transfer 3.986004418e5 1500 6000 20 6678 0.5 5 500 2 [0,1] [[0,0],[0.5,0.5]] [0.5,0.5] traj_plot </code>
                  </p>
                  My implementation of this boundary value problem solver can be found here:
                  <a href='https://github.com/gurgentus/ccst/blob/master/nums/CollocationSolver.cpp'> C++ Code </a>
                  <p>
                  The resulting plots can be displayed with
                </p>
                <p>
                  <code> gdisplay traj_plot </code> and <code> gdisplay traj_plot_control </code>
                </p>
                <p>
                  <img src="orbit_transfer.png"> </img>
                </p>
                </div>
                <div class="tab-pane" id="nums_tab">
                  <h1>Collocation Method</h1>
                  We consider a system of differential equations of the form
                  $$ y' = f(t,y) $$
                  $$ g(y(a), y(b)) = 0$$
                  For fixed $t$ and $y$, let $A = \frac{\partial f}{\partial y}(t,y)$,
                  $B_1 = \partial_1 g$, $B_2 = \partial_2 g$
                </div>
                <div class="tab-pane" id="scene_segment_tab">
                  <h1>Uploading an Image</h1>
                  <p> The first step is to upload an image to be analyzed. To do that expand the menu at the top right corner,
                    above the console screen and upload an image.  Give a name to this image, for example `image1`.  This will be the handle for
                    working with the image from the console.
                  </p>
                  <p>
                  After uploading the file we can display the uploaded image with <code>gdisplay image1</code>.
                  </p>
                  <h1>
                  Comning soon: scene segementation instructions.
                  </h1>
                </div>
              </div>
              </div>
              <div id="col2" class="col-lg-6" id="myScrollspy">
                <div class="embed-responsive embed-responsive-16by9"
                data-spy="affix" data-offset-top="150" data-offset-bottom="200" style='height: 600px; width: 650px'>
                  <p><object class="embed-responsive-item" data="https://gurgentus.pythonanywhere.com/">
                    <embed src="https://gurgentus.pythonanywhere.com/"/></object></p>
                </div>
              </div>

            </div>
          </div>

        </div>
        <hr>

        <footer class="footer">
            <p>&copy; gurgentus</p>
        </footer>

    </div>

  </body>
</html>
